/*
* Implementation of the Grid class, representing a grid of squares.
* Implementation of all public and private methods.
*/
#include "Grid.h"
#include <iostream>
#include <thread>

// Constructor method for Grid object
Grid::Grid(int aWindowWidth, int aWindowHeight, sf::RenderWindow& aWindow) : windowWidth{ aWindowWidth }, windowHeight{ aWindowHeight }, window{ aWindow } {
	// Calculate number of tiles given resolution and tile dimension
	xTiles = windowWidth / 30;
	yTiles = windowHeight / 30;

	// Define default start and end square
	startPosition = { 0 ,0 };
	endPosition = { xTiles - 1 , yTiles - 1 };

	// Initialize all squares within grid
	for (int i = 0; i < xTiles * yTiles; ++i) {	// xTiles * yTiles = all squares within grid
		squares.emplace_back(sf::Vector2f(30, 30));	// Add each SFML rectangle of dimensions x=30, y=30 to vector of squares
	}

	// Initialize position and graphics of all squares within grid
	for (int i = 0; i < xTiles; i++) {
		for (int j = 0; j < yTiles; j++) {
			squares[i * xTiles + j].setPosition(sf::Vector2f(i * 30, j * 30)); // Position must account for square dimension of 30
			squares[i * xTiles + j].setFillColor(freeColor);
			squares[i * xTiles + j].setOutlineColor(sf::Color::Black);
			squares[i * xTiles + j].setOutlineThickness(2);
		}
	}

	// Update color of starting and ending squares
	squares[startPosition.xPosition * xTiles + startPosition.yPosition].setFillColor(startColor);
	squares[endPosition.xPosition * xTiles + endPosition.yPosition].setFillColor(endColor);
}

// Method for drawing grid to SFML window
void Grid::drawGrid() {
	// Using an iterator to iterate through each SFML rectangle within squares vector
	for (const auto& square : squares) {
		window.draw(square); // Draw each square to the window
	}
}

// Method for drawing a path (generated by Dijkstra's or A*) to SFML window
void Grid::drawPath() {
	// Check for empty vertices vector
	if (pathVertices.size() > 0) {
		window.draw(&pathVertices[0], pathVertices.size(), sf::Lines);
	}
}

// Method for defining a wall within grid
void Grid::setWall(sf::Vector2i anObstacle) {
	// Validate wall position
	if (outofBounds(anObstacle.x, anObstacle.y)) {
		return;
	}

	Position wallPosition = { anObstacle.x, anObstacle.y };

	// If position is already a wall, remove the wall
	if (getSquareColor(wallPosition) == wallColor) {
		setSquareColor(wallPosition, freeColor);
		walls.erase(std::remove(walls.begin(), walls.end(), wallPosition), walls.end());
		return;
	}

	// Check if position is starting square
	if (getSquareColor(wallPosition) == startColor) {
		return;
	}

	// Check if position is ending square
	if (getSquareColor(wallPosition) == endColor) {
		return;
	}

	// If method reaches this point, position is validated, so add wall to grid
	setSquareColor(wallPosition, wallColor);
	walls.emplace_back(wallPosition);
}

// Method for explicitly defining ending position
void Grid::setEnd(sf::Vector2i aPosition) {
	// Validate position
	if (outofBounds(aPosition.x, aPosition.y)) {
		return;
	}

	Position newEnd = { aPosition.x, aPosition.y };
	Position currentEnd = endPosition;

	// Check for newEnd already at current end position
	if (getSquareColor(newEnd) == endColor) {
		return;
	}

	// Check for newEnd at start position
	if (getSquareColor(newEnd) == startColor) {
		return;
	}

	// newEnd is eligible for assignment of end position if it passes previous conditions and is of freeColor
	if (getSquareColor(newEnd) == freeColor) {
		setSquareColor(newEnd, endColor);
		updateEnd(newEnd);
		setSquareColor(currentEnd, freeColor); // Change color of previous end position
	}
}
// Method for explicitly defining starting position
void Grid::setStart(sf::Vector2i aPosition) {
	// Validate position
	if (outofBounds(aPosition.x, aPosition.y)) {
		return;
	}

	Position newStart = { aPosition.x, aPosition.y };
	Position currentStart = startPosition;

	// Check for newStart already at current start position
	if (getSquareColor(newStart) == startColor) {
		return;
	}

	// Check for newStart at end position
	if (getSquareColor(newStart) == endColor) {
		return;
	}

	// newStart is eligible for assignment of start position if it passes previous conditions and is of freeColor
	if (getSquareColor(newStart) == freeColor) {
		setSquareColor(newStart, startColor);
		updateStart(newStart);
		setSquareColor(currentStart, freeColor);
	}
}

// Method for coloring a processed square (for use with Dijkstra's or A*)
void Grid::colorProcessedSquare(const Position &aPosition) {
	// Check for position at start or end positions
	if (aPosition == startPosition || aPosition == endPosition) {
		return;
	}
	// Call helper function
	setSquareColor(aPosition, processedColor);
}

// Method for coloring a processing square (for use with Dijkstra's or A*)
void Grid::colorProcessingSquare(const Position &aPosition) {
	// Check for position at start or end positions
	if (aPosition == startPosition || aPosition == endPosition) {
		return;
	}
	// Call helper function
	setSquareColor(aPosition, processingColor);
}

// Method for adding vertices to path vector such that vertices are half dimension of squares
void Grid::loadPath(const Position& aPosition, const Position& anotherPosition)
{
	pathVertices.push_back(sf::Vertex(sf::Vector2f(aPosition.xPosition * 30 + (30 / 2), aPosition.yPosition * 30 + (30 / 2))));
	pathVertices.push_back(sf::Vertex(sf::Vector2f(anotherPosition.xPosition * 30 + (30 / 2), anotherPosition.yPosition * 30 + (30 / 2))));
}

// Accessor method for walls vector
std::vector<Position> Grid::getWallPositions() const {
	return walls;
}

// Accessor method for number of squares horizontally and vertically, returned as an int 2-tuple
std::tuple<int, int> Grid::getNumberOfSquares() const {
	return std::make_tuple(xTiles, yTiles);
}

// Accessor method for endPosition
Position Grid::getEndPosition() const {
	return endPosition;
}

// Accessor method for startPosition
Position Grid::getStartPosition() const {
	return startPosition;
}

// Helper function for setStart method
void Grid::updateStart(const Position &newEnd) {
	startPosition.xPosition = newEnd.xPosition;
	startPosition.yPosition = newEnd.yPosition;
}

// Helper function for setEnd method
void Grid::updateEnd(const Position& newEnd) {
	endPosition.xPosition = newEnd.xPosition;
	endPosition.yPosition = newEnd.yPosition;
}

// Helper function for accessing square color at given position
sf::Color Grid::getSquareColor(const Position &aPosition) const {
	return squares[aPosition.xPosition * xTiles + aPosition.yPosition].getFillColor();
}

// Helper function for mutating square color at given position with given color
void Grid::setSquareColor(const Position &aPosition, const sf::Color &aColor) {
	squares[aPosition.xPosition * xTiles + aPosition.yPosition].setFillColor(aColor);
}

// Helper function for determining if coordinates are within bounds of grid
bool Grid::outofBounds(int xPosition, int yPosition) {
	// Within bounds, return true
	if (xPosition < 0 || yPosition < 0 || xPosition >= windowWidth || yPosition >= windowHeight) {
		return true;
	}
	// Out of bounds
	return false;
}